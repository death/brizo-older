/** @file opcode.h \brief Brizo opcode declarations. */
// $Workfile: opcode.h $
//
// Brizo Disassembler by DEATH, 2003-2004
//
// Opcode class header.
//
// $Author: Death $
// $Revision: 16 $
// $Date: 11/22/04 21:33 $
//
// $NoKeywords: $
//
#ifndef BRIZO_INC_OPCODE_H
#define BRIZO_INC_OPCODE_H

#include <cstddef>
#include "brizo.h"
#include "prefix.h"

namespace Brizo_DE20041115
{

/// IA32 opcode type
enum OpcodeType
{
    O_ADD,
    O_PUSH,
    O_POP,
    O_OR,
    O_ADC,
    O_SBB,
    O_AND,
    O_DAA,
    O_SUB,
    O_DAS,
    O_XOR,
    O_AAA,
    O_CMP,
    O_AAS,
    O_INC,
    O_DEC,
    O_PUSHA,
    O_POPA,
    O_BOUND,
    O_ARPL,
    O_IMUL,
    O_INS,
    O_OUTS,
    O_JO,
    O_JNO,
    O_JB,
    O_JNB,
    O_JZ,
    O_JNZ,
    O_JBE,
    O_JNBE,
    O_JS,
    O_JNS,
    O_JP,
    O_JNP,
    O_JL,
    O_JNL,
    O_JLE,
    O_JNLE,
    O_TEST,
    O_XCHG,
    O_MOV,
    O_LEA,
    O_PAUSE,
    O_NOP,
    O_CBW,
    O_CWD,
    O_CALLF,
    O_FWAIT,
    O_PUSHF,
    O_POPF,
    O_SAHF,
    O_LAHF,
    O_MOVS,
    O_CMPS,
    O_STOS,
    O_LODS,
    O_SCAS,
    O_RETN,
    O_LES,
    O_LDS,
    O_ENTER,
    O_LEAVE,
    O_RETF,
    O_INT3,
    O_INT,
    O_INTO,
    O_IRET,
    O_AAM,
    O_AAD,
    O_XLAT,
//  O_ESC,  // Escape to co-processor instruction set
    O_LOOPNE,
    O_LOOPE,
    O_LOOP,
    O_JCXZ,
    O_IN,
    O_OUT,
    O_CALL,
    O_JMP,
    O_HLT,
    O_CMC,
    O_CLC,
    O_STC,
    O_CLI,
    O_STI,
    O_CLD,
    O_STD,
    O_UNKNOWN,
    O_ROL,
    O_ROR,
    O_RCL,
    O_RCR,
    O_SHL,
    O_SHR,
    O_SAR,
    O_NOT,
    O_NEG,
    O_MUL,
    O_DIV,
    O_IDIV,
    O_LAR,
    O_LSL,
    O_CLTS,
    O_INVD,
    O_WBINVD,
    O_UD2,
    O_MOVUPS,
    O_MOVSS,
    O_MOVUPD,
    O_MOVSD,
    O_MOVLPD,
    O_MOVHLPS,
    O_MOVLPS,
    O_UNPCKLPS,
    O_UNPCKLPD,
    O_UNPCKHPS,
    O_UNPCKHPD,
    O_MOVHPD,
    O_MOVLHPS,
    O_MOVHPS,
    O_SLDT,
    O_STR,
    O_LLDT,
    O_LTR,
    O_VERR,
    O_VERW,
    O_SGDT,
    O_SIDT,
    O_LGDT,
    O_LIDT,
    O_SMSW,
    O_LMSW,
    O_INVLPG,
    O_PREFETCHNTA,
    O_PREFETCHT0,
    O_PREFETCHT1,
    O_PREFETCHT2,
    O_MOVAPD,
    O_MOVAPS,
    O_CVTPI2PS,
    O_CVTSI2SS,
    O_CVTPI2PD,
    O_CVTSI2SD,
    O_MOVNTPD,
    O_MOVNTPS,
    O_CVTTPD2PI,
    O_CVTTSS2SI,
    O_CVTTSD2SI,
    O_CVTTPS2PI,
    O_CVTPD2PI,
    O_CVTSS2SI,
    O_CVTSD2SI,
    O_CVTPS2PI,
    O_UCOMISS,
    O_UCOMISD,
    O_COMISS,
    O_COMISD,
    O_WRMSR,
    O_RDTSC,
    O_RDMSR,
    O_RDPMC,
    O_SYSENTER,
    O_SYSEXIT,
    O_MOVNTI,
    O_CMOVO,
    O_CMOVNO,
    O_CMOVB,
    O_CMOVAE,
    O_CMOVE,
    O_CMOVNE,
    O_CMOVBE,
    O_CMOVA,
    O_CMOVS,
    O_CMOVNS,
    O_CMOVP,
    O_CMOVNP,
    O_CMOVL,
    O_CMOVNL,
    O_CMOVLE,
    O_CMOVNLE,
    O_MOVMSKPD,
    O_MOVMSKPS,
    O_SQRTPS,
    O_SQRTPD,
    O_SQRTSS,
    O_SQRTSD,
    O_RSQRTPS,
    O_RSQRTSS,
    O_RCPPS,
    O_RCPSS,
    O_ANDPS,
    O_ANDPD,
    O_ANDNPS,
    O_ANDNPD,
    O_ORPS,
    O_ORPD,
    O_XORPS,
    O_XORPD,
    O_ADDPS,
    O_ADDPD,
    O_ADDSS,
    O_ADDSD,
    O_MULPS,
    O_MULPD,
    O_MULSS,
    O_MULSD,
    O_CVTPS2PD,
    O_CVTSS2SD,
    O_CVTPD2PS,
    O_CVTSD2SS,
    O_CVTPS2DQ,
    O_CVTTPS2DQ,
    O_CVTDQ2PS,
    O_SUBPD,
    O_SUBSS,
    O_SUBSD,
    O_SUBPS,
    O_MINPD,
    O_MINSS,
    O_MINSD,
    O_MINPS,
    O_DIVPD,
    O_DIVSS,
    O_DIVSD,
    O_DIVPS,
    O_MAXPD,
    O_MAXSS,
    O_MAXSD,
    O_MAXPS,
    O_PUNPCKLBW,
    O_PUNPCKLWD,
    O_PUNPCKLDQ,
    O_PACKSSWB,
    O_PCMPGTB,
    O_PCMPGTW,
    O_PCMPGTD,
    O_PACKUSWB,
    O_PUNPCKHBW,
    O_PUNPCKHWD,
    O_PUNPCKHDQ,
    O_PACKSSDW,
    O_PUNPCKLQDQ,
    O_PUNPCKHQDQ,
    O_MOVD,
    O_MOVDQA,
    O_MOVDQU,
    O_MOVQ,
    O_PSHUFD,
    O_PSHUFHW,
    O_PSHUFLW,
    O_PSHUFW,
    O_PSRLW,
    O_PSRAW,
    O_PSLLW,
    O_PSRLD,
    O_PSRAD,
    O_PSLLD,
    O_PSRLQ,
    O_PSRLDQ,
    O_PSLLQ,
    O_PSLLDQ,
    O_PCMPEQB,
    O_PCMPEQW,
    O_PCMPEQD,
    O_EMMS,
    O_MMXUD,
    O_SETO,
    O_SETNO,
    O_SETB,
    O_SETNB,
    O_SETZ,
    O_SETNZ,
    O_SETBE,
    O_SETNBE,
    O_SETS,
    O_SETNS,
    O_SETP,
    O_SETNP,
    O_SETL,
    O_SETNL,
    O_SETLE,
    O_SETNLE,
    O_CPUID,
    O_BT,
    O_SHLD,
    O_RSM,
    O_BTS,
    O_SHRD,
    O_FXSAVE,
    O_FXRSTOR,
    O_LDMXCSR,
    O_STMXCSR,
    O_CLFLUSH,
    O_LFENCE,
    O_MFENCE,
    O_SFENCE,
    O_CMPXCHG,
    O_LSS,
    O_BTR,
    O_LFS,
    O_LGS,
    O_MOVZX,
    O_BTC,
    O_BSF,
    O_BSR,
    O_MOVSX,
    O_XADD,
    O_CMPSS,
    O_CMPSD,
    O_CMPPD,
    O_CMPPS,
    O_PINSRW,
    O_PEXTRW,
    O_SHUFPD,
    O_SHUFPS,
    O_CMPXCHG8B,
    O_BSWAP,
    O_PADDQ,
    O_PMULLW,
    O_MOVQ2DQ,
    O_MOVDQ2Q,
    O_PMOVMSKB,
    O_PSUBUSB,
    O_PSUBUSW,
    O_PMINUB,
    O_PAND,
    O_PADDUSB,
    O_PADDUSW,
    O_PMAXUB,
    O_PANDN,
    O_PAVGB,
    O_PAVGW,
    O_PMULHUW,
    O_PMULHW,
    O_CVTTPD2DQ,
    O_CVTDQ2PD,
    O_CVTPD2DQ,
    O_MOVNTDQ,
    O_MOVNTQ,
    O_PSUBSB,
    O_PSUBSW,
    O_PMINSW,
    O_POR,
    O_PADDSB,
    O_PADDSW,
    O_PMAXSW,
    O_PXOR,
    O_PMULUDQ,
    O_PMADDWD,
    O_PSADBW,
    O_MASKMOVDQU,
    O_MASKMOVQ,
    O_PSUBB,
    O_PSUBW,
    O_PSUBD,
    O_PSUBQ,
    O_PADDB,
    O_PADDW,
    O_PADDD,
    // FPU Instructions
    O_FADD,
    O_FMUL,
    O_FCOM,
    O_FCOMP,
    O_FSUB,
    O_FSUBR,
    O_FDIV,
    O_FDIVR,
    O_FLD,
    O_FST,
    O_FSTP,
    O_FLDENV,
    O_FLDCW,
    O_FSTENV,
    O_FSTCW,
    O_FXCH,
    O_FNOP,
    O_FCHS,
    O_FABS,
    O_FTST,
    O_FXAM,
    O_FLD1,
    O_FLDL2T,
    O_FLDL2E,
    O_FLDPI,
    O_FLDLG2,
    O_FLDLN2,
    O_FLDZ,
    O_F2XM1,
    O_FYL2X,
    O_FPTAN,
    O_FPATAN,
    O_FXTRACT,
    O_FPREM1,
    O_FDECSTP,
    O_FINCSTP,
    O_FPREM,
    O_FYL2XP1,
    O_FSQRT,
    O_FSINCOS,
    O_FRNDINT,
    O_FSCALE,
    O_FSIN,
    O_FCOS,
    O_FIADD,
    O_FIMUL,
    O_FICOM,
    O_FICOMP,
    O_FISUB,
    O_FISUBR,
    O_FIDIV,
    O_FIDIVR,
    O_FCMOVB,
    O_FCMOVE,
    O_FCMOVBE,
    O_FCMOVU,
    O_FUCOMPP,
    O_FILD,
    O_FIST,
    O_FISTP,
    O_FCMOVNB,
    O_FCMOVNE,
    O_FCMOVNBE,
    O_FCMOVNU,
    O_FCLEX,
    O_FINIT,
    O_FUCOMI,
    O_FCOMI,
    O_FRSTOR,
    O_FSAVE,
    O_FSTSW,
    O_FFREE,
    O_FUCOM,
    O_FUCOMP,
    O_FADDP,
    O_FMULP,
    O_FCOMPP,
    O_FSUBRP,
    O_FSUBP,
    O_FDIVRP,
    O_FDIVP,
    O_FBLD,
    O_FBSTP,
    O_FUCOMIP,
    O_FCOMIP,
    // SSE3
    O_ADDSUBPD,
    O_ADDSUBPS,
    O_FISTTP,
    O_HADDPD,
    O_HADDPS,
    O_HSUBPD,
    O_HSUBPS,
    O_MONITOR,
    O_MWAIT,
    O_LDDQU,
    O_MOVDDUP,
    O_MOVSHDUP,
    O_MOVSLDUP
};

/// Operand addressing mode
enum AddressingMode
{
    AM_NONE = 0,
    AM_DIRECT_ADDRESS = 'A',
    AM_CONTROL_REGISTER = 'C',
    AM_DEBUG_REGISTER = 'D',
    AM_MODRM = 'E',
    AM_EFLAGS = 'F',
    AM_GENERAL_REGISTER = 'G',
    AM_IMMEDIATE_DATA = 'I',
    AM_RELATIVE_OFFSET = 'J',
    AM_MODRM_MEMORY = 'M',
    AM_NO_MODRM = 'O',
    AM_MODRM_MMX = 'P',
    AM_MODRM_MMX_MEMORY = 'Q',
    AM_MODRM_GENERAL_REGISTER = 'R',
    AM_MODRM_SEGMENT = 'S',
    AM_MODRM_TEST = 'T',
    AM_MODRM_XMM = 'V',
    AM_MODRM_XMM_MEMORY = 'W',
    AM_DSSI = 'X',
    AM_ESDI = 'Y'
};

/// Operand type
enum OperandType
{
    OT_NONE = 0,
    OT_TWO_OPERANDS = 'a',
    OT_ABS_BYTE = 'b',
    OT_BYTE_WORD = 'c',
    OT_ABS_DWORD = 'd',
    OT_ABS_DQWORD = 'dq',
    OT_32_48_PTR = 'p',
    OT_MMX_REG = 'pi',
    OT_128_FLOAT = 'ps',
    OT_128_DOUBLE = 'pd',
    OT_ABS_QWORD = 'q',
    OT_PDESC = 's',
    OT_128_DOUBLE_SCALAR = 'sd',
    OT_128_SCALAR = 'ss',
    OT_DWORD_REG = 'si',
    OT_WORD_DWORD = 'v',
    OT_ABS_WORD = 'w',
    // Extended operand types not defined by Intel specification
    OT_FPU_SINGLE = 'fd',
    OT_FPU_DOUBLE = 'fq',
    OT_FPU_EXTENDED = 'ft',
    OT_FPU_ENV = 'fe',
    OT_FPU_STATE = 'fs',
    OT_FPU_BCD = 'fb'
};

// HACK: Part1, REG_NONE is a lame windows definition, undef it if needed
// In winnt.h it's #define REG_NONE (0)
// Luckily, we use REG_NONE as zero as well
#ifdef REG_NONE
#define BRIZO_HACK_REDEFINE_REG_NONE
#undef REG_NONE
#endif

/// Register type
enum Register
{
    REG_NONE = 0,
    REG_AL,
    REG_AH,
    REG_AX,
    REG_EAX,
    REG_E_AX,
    REG_BL,
    REG_BH,
    REG_BX,
    REG_EBX,
    REG_E_BX,
    REG_CL,
    REG_CH,
    REG_CX,
    REG_ECX,
    REG_E_CX,
    REG_DL,
    REG_DH,
    REG_DX,
    REG_EDX,
    REG_E_DX,
    REG_SI,
    REG_ESI,
    REG_E_SI,
    REG_DI,
    REG_EDI,
    REG_E_DI,
    REG_SP,
    REG_ESP,
    REG_E_SP,
    REG_BP,
    REG_EBP,
    REG_E_BP,
    REG_CS,
    REG_DS,
    REG_ES,
    REG_FS,
    REG_GS,
    REG_SS,
    // Pseudo-registers
    REG_VAL_1,
    // XMM registers
    REG_XMM0,
    REG_XMM1,
    REG_XMM2,
    REG_XMM3,
    REG_XMM4,
    REG_XMM5,
    REG_XMM6,
    REG_XMM7,
    // Control registers
    REG_CR0,
    REG_CR1,
    REG_CR2,
    REG_CR3,
    REG_CR4,
    REG_CR5,
    REG_CR6,
    REG_CR7,
    // Debug registers
    REG_DR0,
    REG_DR1,
    REG_DR2,
    REG_DR3,
    REG_DR4,
    REG_DR5,
    REG_DR6,
    REG_DR7,
    // Test registers
    REG_TR0,
    REG_TR1,
    REG_TR2,
    REG_TR3,
    REG_TR4,
    REG_TR5,
    REG_TR6,
    REG_TR7,
    // MMX registers
    REG_MM0,
    REG_MM1,
    REG_MM2,
    REG_MM3,
    REG_MM4,
    REG_MM5,
    REG_MM6,
    REG_MM7,
    // FPU stack
    REG_ST0,
    REG_ST1,
    REG_ST2,
    REG_ST3,
    REG_ST4,
    REG_ST5,
    REG_ST6,
    REG_ST7
};

// HACK: Part 2, redefine REG_NONE if needed
#ifdef BRIZO_HACK_REDEFINE_REG_NONE
#define REG_NONE (0)
#endif

/// Operand structure
struct Operand
{
    Register reg;               ///< Register used
    AddressingMode amode;       ///< Addressing mode
    OperandType otype;          ///< Operand type
};

/// Opcode flags
enum OpcodeFlags
{
    OF_1BYTE = 0x01,      ///< 1-byte opcode
    OF_2BYTE = 0x02,      ///< 2-byte opcode
    OF_MRMBITS = 0x04,    ///< 3 bits of mr/m also considered part of the opcode
    OF_USEPREFIX = 0x08,  ///< New opcodes that use prefix to specify operation
    OF_MRM_LEQ_BF = 0x10, ///< Opcode fits when ModR/M is lower or equal to BF
    OF_MRM_G_BF = 0x20,   ///< Opcode fits when ModR/M is greater than BF
    OF_MODMEM = 0x40,     ///< Opcode extension when MOD bits aren't 11b
    OF_MOD11 = 0x80,      ///< Opcode extension when MOD bits are 11b
    OF_MODBOTH = OF_MODMEM | OF_MOD11, ///< Opcode extension in either case
    OF_FPU = 0x100        ///< Opcode is an FPU opcode
};

/// Opcode structure
struct Opcode
{
    /// Retrieve number of operands for this opcode
    /// @return A value indicating the number of operands
    std::size_t GetOperandCount(void) const;

    /// Determine wether the opcode is a string operation
    /// @return true if the opcode is a string operation, false if not
    bool IsStringOperation(void) const;

    /// Determine wether the opcode is a branch operation
    /// @return true if the opcode is a branch operation, false if not
    bool IsJccOperation(void) const;

    unsigned int flags;         ///< OpcodeFlags bits value
    unsigned short code;        ///< The opcode itself
    unsigned char mrmbits;      ///< ModR/M set bits
    PrefixEnum prefix;          ///< Some opcodes are determined with help of a prefix

    OpcodeType op;              ///< The opcode type
    Operand operands[3];        ///< The opcode's operands
};

}

#endif // BRIZO_INC_OPCODE_H
